Title: PCG32: The Perfect PRNG for Roguelikes
Category: Articles
Slug: pcg32-the-perfect-prng-for-roguelikes
Tags: gamedev roguelikes
Status: draft

Roguelikes are games that, among other things, have a lot of procedurally
generated content. To generate content, we need random numbers. And to get
random numbers, we need a **pseudo-random number generator**.

Not only do we want random numbers, but we want _predictable_ random numbers!
We want players to be able to share seeds and see who does better in the same
situation, while also giving people a completely fresh experience every time
they play.

But we can't just create a PRNG with a seed and be done. If we use the same
PRNG for both level generation and combat, for example, then our second level
might change based on how many times the player got into a fight!

So we need to be clever about how we create and store our PRNGs, to ensure
that the procedurally generated maps are not affected by anything that happens
during gameplay.

But if we use the [PCG family of PRNGs](http://www.pcg-random.org), our job
is a lot easier. There are many variants of PCG, but in this post I'll be
referring only to PCG32, the one that generates 32-bit unsigned integers and
keeps its state as two 64-bit unsigned integers.

# What makes PCG unique?

PCG has a lot going for it, and [the web site does a good job of explaining
the advantages](http://www.pcg-random.org), but for roguelike developers, it
all comes down to the API.

A PCG instance is created with not one, but **two** values: the *seed*, and the
*stream*. The seed matches the traditional idea of a PRNG seed, but the stream
is something new: it lets you pick from **multiple streams of random numbers**
generated by the same seed!

```swift
for seed: UInt64 in [12345, 67890] {
  print("Seed:", seed)
  for seq: UInt64 in [0, 1, 2] {

    // two numbers: seed and seq
    let rng = PCG32Generator(seed: seed, seq: seq)

    let values = [0,1,2,3,4,5,6,7,8,9].map({_ in "\(rng.get(upperBound: 100))" })
    print("Stream \(seq):", values.joined(separator: ", "))
  }
  print()
}
```

```
Seed: 12345
Stream 0: 9, 26, 14, 74, 3, 82, 86, 75, 82, 92
Stream 1: 24, 4, 3, 76, 54, 90, 40, 98, 15, 34
Stream 2: 60, 17, 46, 15, 6, 30, 0, 68, 29, 91

Seed: 67890
Stream 0: 54, 68, 74, 56, 1, 63, 43, 47, 21, 96
Stream 1: 36, 16, 80, 58, 36, 31, 5, 14, 29, 73
Stream 2: 89, 61, 71, 58, 85, 14, 70, 6, 59, 31
```

This means you can start your game with one seed, and then lazily create
individual PCG instances for each level at the time you need them, without
worrying that your PRNG state has been messed up just by playing the game.

And once we've created a PCG instance, we only need to store two unsigned
integers! Serialization's a snap.

# Language support

PCG32 is very easy to implement, so it has broad language support, even though
the algorithm was only introduced in 2014. I wrote two implementations myself:
[Python](https://github.com/irskep/clubsandwich/blob/master/clubsandwich/pcg32.py)
and [Swift](https://github.com/irskep/RogueKit/blob/master/Sources/RogueKit/Util/PCG32.swift).
But you should be able to find a good implementation for your favorite language
just by searching Google. And if you can't find one, it really isn't too hard
to do! It's just a handful of bitwise operations.