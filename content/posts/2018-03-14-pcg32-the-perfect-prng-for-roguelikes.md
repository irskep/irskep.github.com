Title: PCG32: The Perfect PRNG for Roguelikes

Category: Articles
Slug: pcg32-the-perfect-prng-for-roguelikes

Tags: gamedev roguelikes
Status: draft

A **pseudo-random number generator** uses math to generate numbers that appear
random to users, but are completely deterministic. They are used in roguelike
games to generate levels, determine combat outcomes, and much more.

In roguelikes, each game typically has a unique _random seed_. This seed
affects how the generated levels are laid out. That way, players can share
seeds with each other to see who does better in the same situation.

When designing a roguelike, it can be tricky to design the game so that the
levels turn out the same way every time for every game. We must be careful not
to use the same PRNG instance for both level generation and combat, for
example, or else the player's actions during the game will affect how future
maps look!

But if you use the [PCG family of PRNGs](http://www.pcg-random.org), our job
is a lot easier. There are many variants of PCG, but in this post I'll be
referring only to PCG32, the one that generates 32-bit unsigned integers and
keeps its state as two 64-bit unsigned integers.

# What makes PCG unique?

PCG has a lot going for it, and [the web site does a good job of explaining
the advantages](http://www.pcg-random.org), but for roguelike developers, it
all comes down to the API ([source](https://github.com/imneme/pcg-c-basic/blob/master/pcg_basic.h)).

A PCG instance is created with not one, but **two** values: the *seed*, and the
*stream*. The seed matches the traditional idea of a PRNG seed, but the stream
is something new: it lets you pick from *multiple streams of random numbers*
generated by the same seed!

```
Seed: 12345
Stream 0: 9, 26, 14, 74, 3, 82, 86, 75, 82, 92
Stream 1: 24, 4, 3, 76, 54, 90, 40, 98, 15, 34
Stream 2: 60, 17, 46, 15, 6, 30, 0, 68, 29, 91

Seed: 67890
Stream 0: 54, 68, 74, 56, 1, 63, 43, 47, 21, 96
Stream 1: 36, 16, 80, 58, 36, 31, 5, 14, 29, 73
Stream 2: 89, 61, 71, 58, 85, 14, 70, 6, 59, 31
```

This means you can start your game with one seed, and then lazily create
individual PCG instances for each level at the time you need them, without
worrying that your PRNG state has been messed up just by playing the game.

And once you've created a PCG instance, you only need to store two unsigned
integers! Serialization's a snap.

# Language support

PCG32 is very easy to implement, so it has broad language support, even though
the algorithm was only introduced in 2014. I wrote two implementations myself:
[Python](https://github.com/irskep/clubsandwich/blob/master/clubsandwich/pcg32.py)
and [Swift](https://github.com/irskep/RogueKit/blob/master/Sources/RogueKit/Util/PCG32.swift).
But you should be able to find a good implementation for your favorite language
just by searching Google. And if you can't find one, it really isn't too hard
to do! It's just a handful of bitwise operations.